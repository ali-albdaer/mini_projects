<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screw Dislocation 3D Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            color: #fff;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            max-width: 350px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #controls::-webkit-scrollbar {
            width: 8px;
        }

        #controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        #controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        h1 {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #e0e0e0;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #667eea;
            font-weight: bold;
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 0.9em;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            border: none;
            border-radius: 5px;
            background: #667eea;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: 300px;
        }

        .info-panel h3 {
            font-size: 1em;
            margin-bottom: 10px;
            color: #667eea;
        }

        .info-panel p {
            font-size: 0.85em;
            line-height: 1.5;
            color: #e0e0e0;
        }

        #recording-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
        }

        .dropdown-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .dropdown-content.active {
            max-height: 500px;
        }

        .dropdown-header {
            cursor: pointer;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dropdown-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .dropdown-arrow {
            transition: transform 0.3s;
        }

        .dropdown-arrow.active {
            transform: rotate(180deg);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div id="controls">
            <h1>ðŸ”¬ Screw Dislocation Simulator</h1>
            
            <!-- Main Parameters -->
            <div class="control-group">
                <label>Lattice Size: <span class="value-display" id="lattice-size-display">10</span></label>
                <input type="range" id="lattice-size" min="5" max="20" value="10" step="1">
            </div>

            <div class="control-group">
                <label>Lattice Constant (Ã…): <span class="value-display" id="lattice-constant-display">3.5</span></label>
                <input type="range" id="lattice-constant" min="2.0" max="5.0" value="3.5" step="0.1">
            </div>

            <div class="control-group">
                <label>Burgers Vector Magnitude: <span class="value-display" id="burgers-display">1.0</span></label>
                <input type="range" id="burgers-vector" min="0.5" max="2.0" value="1.0" step="0.1">
            </div>

            <div class="control-group">
                <label>Dislocation Line Position: <span class="value-display" id="dislocation-pos-display">0.5</span></label>
                <input type="range" id="dislocation-position" min="0.0" max="1.0" value="0.5" step="0.05">
            </div>

            <div class="control-group">
                <label>Displacement Magnitude: <span class="value-display" id="displacement-display">1.0</span></label>
                <input type="range" id="displacement-magnitude" min="0.0" max="2.0" value="1.0" step="0.1">
            </div>

            <div class="control-group">
                <label>Rotation Speed: <span class="value-display" id="rotation-speed-display">0.5</span></label>
                <input type="range" id="rotation-speed" min="0.0" max="2.0" value="0.5" step="0.1">
            </div>

            <!-- Advanced Settings Dropdown -->
            <div class="dropdown-header" id="advanced-toggle">
                <span>Advanced Settings</span>
                <span class="dropdown-arrow">â–¼</span>
            </div>
            <div class="dropdown-content" id="advanced-content">
                <div class="control-group">
                    <label>Atom Size: <span class="value-display" id="atom-size-display">0.3</span></label>
                    <input type="range" id="atom-size" min="0.1" max="0.8" value="0.3" step="0.05">
                </div>

                <div class="control-group">
                    <label>Bond Thickness: <span class="value-display" id="bond-thickness-display">0.1</span></label>
                    <input type="range" id="bond-thickness" min="0.05" max="0.3" value="0.1" step="0.01">
                </div>

                <div class="control-group">
                    <label>Visualization Style:</label>
                    <select id="viz-style">
                        <option value="atoms-bonds">Atoms & Bonds</option>
                        <option value="atoms-only">Atoms Only</option>
                        <option value="bonds-only">Bonds Only</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Color Scheme:</label>
                    <select id="color-scheme">
                        <option value="displacement">Displacement Gradient</option>
                        <option value="height">Height-based</option>
                        <option value="distance">Distance from Dislocation</option>
                        <option value="single">Single Color</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Crystal Structure:</label>
                    <select id="crystal-structure">
                        <option value="bcc">BCC (Body-Centered Cubic)</option>
                        <option value="fcc">FCC (Face-Centered Cubic)</option>
                        <option value="simple">Simple Cubic</option>
                    </select>
                </div>
            </div>

            <!-- Export Section -->
            <div class="export-section">
                <h3 style="font-size: 1.1em; margin-bottom: 10px;">Export Animation</h3>
                
                <div class="control-group">
                    <label>Duration (seconds): <span class="value-display" id="duration-display">5</span></label>
                    <input type="range" id="export-duration" min="2" max="30" value="5" step="1">
                </div>

                <div class="control-group">
                    <label>FPS: <span class="value-display" id="fps-display">30</span></label>
                    <input type="range" id="export-fps" min="15" max="60" value="30" step="5">
                </div>

                <div class="control-group">
                    <label>Format:</label>
                    <select id="export-format">
                        <option value="webm">WebM (Video)</option>
                        <option value="gif">GIF</option>
                    </select>
                </div>

                <button id="start-recording">Start Recording</button>
                <button id="stop-recording" disabled>Stop Recording</button>
                <button id="download-export" disabled>Download</button>
            </div>

            <button id="reset-view">Reset Camera</button>
        </div>

        <div id="recording-indicator">
            <div class="recording-dot"></div>
            <span>Recording...</span>
        </div>

        <div class="info-panel">
            <h3>About Screw Dislocations</h3>
            <p>A screw dislocation is a line defect in a crystal lattice where atoms are displaced in a helical pattern around a dislocation line. The Burgers vector is parallel to the dislocation line, creating a spiral ramp-like distortion.</p>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ==================== Scene Setup ====================
        let scene, camera, renderer, controls;
        let latticeGroup;
        let atoms = [];
        let bonds = [];
        let isRecording = false;
        let mediaRecorder;
        let recordedChunks = [];
        let animationId;
        let autoRotate = true;

        // Parameters
        let params = {
            latticeSize: 10,
            latticeConstant: 3.5,
            burgersVector: 1.0,
            dislocationPosition: 0.5,
            displacementMagnitude: 1.0,
            rotationSpeed: 0.5,
            atomSize: 0.3,
            bondThickness: 0.1,
            vizStyle: 'atoms-bonds',
            colorScheme: 'displacement',
            crystalStructure: 'bcc',
            exportDuration: 5,
            exportFps: 30
        };

        // Initialize scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);

            // Grid helper
            const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Mouse controls (simple orbit)
            setupMouseControls();

            // Create initial lattice
            createLattice();

            // Event listeners
            setupEventListeners();

            // Start animation
            animate();
        }

        // ==================== Screw Dislocation Physics ====================
        
        /**
         * Calculate displacement for screw dislocation
         * Based on elastic theory: u_z = (b / 2Ï€) * arctan(y / x)
         * where b is the Burgers vector magnitude
         */
        function calculateScrewDisplacement(x, y, z, dislocationLine) {
            const b = params.burgersVector * params.latticeConstant;
            const dx = x - dislocationLine.x;
            const dy = y - dislocationLine.y;
            
            // Distance from dislocation line
            const r = Math.sqrt(dx * dx + dy * dy);
            
            // Avoid singularity at dislocation core
            if (r < 0.5 * params.latticeConstant) {
                return 0;
            }
            
            // Angle around dislocation line
            const theta = Math.atan2(dy, dx);
            
            // Displacement in z-direction (parallel to dislocation line)
            const uz = (b / (2 * Math.PI)) * theta * params.displacementMagnitude;
            
            return uz;
        }

        // ==================== Lattice Creation ====================
        
        function createLattice() {
            // Clear existing lattice
            if (latticeGroup) {
                scene.remove(latticeGroup);
            }
            atoms = [];
            bonds = [];
            
            latticeGroup = new THREE.Group();
            
            const size = params.latticeSize;
            const a = params.latticeConstant;
            
            // Dislocation line at center (adjustable position)
            const dislocationLine = {
                x: (size / 2) * a * params.dislocationPosition,
                y: (size / 2) * a * params.dislocationPosition,
                z: 0
            };
            
            // Create atoms based on crystal structure
            const atomPositions = [];
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    for (let k = 0; k < size; k++) {
                        const basePositions = getAtomPositionsForStructure(i, j, k, a);
                        
                        basePositions.forEach(pos => {
                            // Apply screw dislocation displacement
                            const uz = calculateScrewDisplacement(pos.x, pos.y, pos.z, dislocationLine);
                            pos.z += uz;
                            
                            atomPositions.push(pos);
                        });
                    }
                }
            }
            
            // Create atom meshes
            atomPositions.forEach(pos => {
                if (params.vizStyle !== 'bonds-only') {
                    createAtom(pos, dislocationLine);
                }
            });
            
            // Create bonds
            if (params.vizStyle !== 'atoms-only') {
                createBonds(atomPositions, a);
            }
            
            // Center the lattice
            const center = new THREE.Vector3(
                (size * a) / 2,
                (size * a) / 2,
                0
            );
            latticeGroup.position.sub(center);
            
            scene.add(latticeGroup);
        }

        function getAtomPositionsForStructure(i, j, k, a) {
            const positions = [];
            const x = i * a;
            const y = j * a;
            const z = k * a;
            
            switch (params.crystalStructure) {
                case 'simple':
                    positions.push({ x, y, z });
                    break;
                    
                case 'bcc':
                    // Corner atoms
                    positions.push({ x, y, z });
                    // Body-centered atom
                    if (i < params.latticeSize - 1 && j < params.latticeSize - 1 && k < params.latticeSize - 1) {
                        positions.push({
                            x: x + a / 2,
                            y: y + a / 2,
                            z: z + a / 2
                        });
                    }
                    break;
                    
                case 'fcc':
                    // Corner atoms
                    positions.push({ x, y, z });
                    // Face-centered atoms
                    if (i < params.latticeSize - 1 && j < params.latticeSize - 1) {
                        positions.push({ x: x + a / 2, y: y + a / 2, z: z });
                    }
                    if (j < params.latticeSize - 1 && k < params.latticeSize - 1) {
                        positions.push({ x: x, y: y + a / 2, z: z + a / 2 });
                    }
                    if (i < params.latticeSize - 1 && k < params.latticeSize - 1) {
                        positions.push({ x: x + a / 2, y: y, z: z + a / 2 });
                    }
                    break;
            }
            
            return positions;
        }

        function createAtom(pos, dislocationLine) {
            const geometry = new THREE.SphereGeometry(params.atomSize, 16, 16);
            const color = getAtomColor(pos, dislocationLine);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 30,
                specular: 0x222222
            });
            
            const atom = new THREE.Mesh(geometry, material);
            atom.position.set(pos.x, pos.y, pos.z);
            
            atoms.push(atom);
            latticeGroup.add(atom);
        }

        function getAtomColor(pos, dislocationLine) {
            switch (params.colorScheme) {
                case 'displacement':
                    // Color based on z displacement
                    const normalizedZ = (pos.z + 10) / 20; // Normalize to 0-1
                    return new THREE.Color().setHSL(0.6 - normalizedZ * 0.3, 1.0, 0.5);
                    
                case 'height':
                    const normalizedY = pos.y / (params.latticeSize * params.latticeConstant);
                    return new THREE.Color().setHSL(normalizedY * 0.7, 1.0, 0.5);
                    
                case 'distance':
                    const dx = pos.x - dislocationLine.x;
                    const dy = pos.y - dislocationLine.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = params.latticeSize * params.latticeConstant;
                    const normalizedDist = Math.min(dist / maxDist, 1);
                    return new THREE.Color().setHSL(normalizedDist * 0.7, 1.0, 0.5);
                    
                case 'single':
                default:
                    return new THREE.Color(0x4488ff);
            }
        }

        function createBonds(atomPositions, a) {
            const maxBondLength = a * 1.5; // Maximum bond length
            
            for (let i = 0; i < atomPositions.length; i++) {
                for (let j = i + 1; j < atomPositions.length; j++) {
                    const pos1 = atomPositions[i];
                    const pos2 = atomPositions[j];
                    
                    const distance = Math.sqrt(
                        Math.pow(pos1.x - pos2.x, 2) +
                        Math.pow(pos1.y - pos2.y, 2) +
                        Math.pow(pos1.z - pos2.z, 2)
                    );
                    
                    if (distance < maxBondLength) {
                        createBond(pos1, pos2);
                    }
                }
            }
        }

        function createBond(pos1, pos2) {
            const direction = new THREE.Vector3(
                pos2.x - pos1.x,
                pos2.y - pos1.y,
                pos2.z - pos1.z
            );
            const length = direction.length();
            direction.normalize();
            
            const geometry = new THREE.CylinderGeometry(
                params.bondThickness,
                params.bondThickness,
                length,
                8
            );
            const material = new THREE.MeshPhongMaterial({
                color: 0x888888,
                shininess: 10,
                transparent: true,
                opacity: 0.6
            });
            
            const bond = new THREE.Mesh(geometry, material);
            
            // Position bond at midpoint
            bond.position.set(
                (pos1.x + pos2.x) / 2,
                (pos1.y + pos2.y) / 2,
                (pos1.z + pos2.z) / 2
            );
            
            // Rotate bond to align with connection
            const up = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
            bond.quaternion.copy(quaternion);
            
            bonds.push(bond);
            latticeGroup.add(bond);
        }

        // ==================== Mouse Controls ====================
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };

        function setupMouseControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                autoRotate = false;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging && latticeGroup) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };

                    rotation.y += deltaMove.x * 0.01;
                    rotation.x += deltaMove.y * 0.01;

                    latticeGroup.rotation.y = rotation.y;
                    latticeGroup.rotation.x = rotation.x;

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Zoom with mouse wheel
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                camera.position.z += e.deltaY * zoomSpeed;
                camera.position.z = Math.max(10, Math.min(100, camera.position.z));
            });
        }

        // ==================== Animation ====================
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Auto-rotate
            if (latticeGroup && autoRotate && params.rotationSpeed > 0) {
                latticeGroup.rotation.y += 0.005 * params.rotationSpeed;
            }
            
            renderer.render(scene, camera);
        }

        // ==================== Event Listeners ====================
        
        function setupEventListeners() {
            // Lattice parameters
            document.getElementById('lattice-size').addEventListener('input', (e) => {
                params.latticeSize = parseInt(e.target.value);
                document.getElementById('lattice-size-display').textContent = e.target.value;
                createLattice();
            });

            document.getElementById('lattice-constant').addEventListener('input', (e) => {
                params.latticeConstant = parseFloat(e.target.value);
                document.getElementById('lattice-constant-display').textContent = e.target.value;
                createLattice();
            });

            document.getElementById('burgers-vector').addEventListener('input', (e) => {
                params.burgersVector = parseFloat(e.target.value);
                document.getElementById('burgers-display').textContent = e.target.value;
                createLattice();
            });

            document.getElementById('dislocation-position').addEventListener('input', (e) => {
                params.dislocationPosition = parseFloat(e.target.value);
                document.getElementById('dislocation-pos-display').textContent = e.target.value;
                createLattice();
            });

            document.getElementById('displacement-magnitude').addEventListener('input', (e) => {
                params.displacementMagnitude = parseFloat(e.target.value);
                document.getElementById('displacement-display').textContent = e.target.value;
                createLattice();
            });

            document.getElementById('rotation-speed').addEventListener('input', (e) => {
                params.rotationSpeed = parseFloat(e.target.value);
                document.getElementById('rotation-speed-display').textContent = e.target.value;
                if (params.rotationSpeed > 0) {
                    autoRotate = true;
                }
            });

            document.getElementById('atom-size').addEventListener('input', (e) => {
                params.atomSize = parseFloat(e.target.value);
                document.getElementById('atom-size-display').textContent = e.target.value;
                createLattice();
            });

            document.getElementById('bond-thickness').addEventListener('input', (e) => {
                params.bondThickness = parseFloat(e.target.value);
                document.getElementById('bond-thickness-display').textContent = e.target.value;
                createLattice();
            });

            document.getElementById('viz-style').addEventListener('change', (e) => {
                params.vizStyle = e.target.value;
                createLattice();
            });

            document.getElementById('color-scheme').addEventListener('change', (e) => {
                params.colorScheme = e.target.value;
                createLattice();
            });

            document.getElementById('crystal-structure').addEventListener('change', (e) => {
                params.crystalStructure = e.target.value;
                createLattice();
            });

            document.getElementById('export-duration').addEventListener('input', (e) => {
                params.exportDuration = parseInt(e.target.value);
                document.getElementById('duration-display').textContent = e.target.value;
            });

            document.getElementById('export-fps').addEventListener('input', (e) => {
                params.exportFps = parseInt(e.target.value);
                document.getElementById('fps-display').textContent = e.target.value;
            });

            // Advanced settings dropdown
            document.getElementById('advanced-toggle').addEventListener('click', () => {
                const content = document.getElementById('advanced-content');
                const arrow = document.querySelector('.dropdown-arrow');
                content.classList.toggle('active');
                arrow.classList.toggle('active');
            });

            // Reset view
            document.getElementById('reset-view').addEventListener('click', () => {
                camera.position.set(30, 30, 30);
                camera.lookAt(0, 0, 0);
                if (latticeGroup) {
                    latticeGroup.rotation.set(0, 0, 0);
                    rotation = { x: 0, y: 0 };
                }
                autoRotate = true;
            });

            // Recording controls
            document.getElementById('start-recording').addEventListener('click', startRecording);
            document.getElementById('stop-recording').addEventListener('click', stopRecording);
            document.getElementById('download-export').addEventListener('click', downloadExport);

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== Recording ====================
        
        function startRecording() {
            const format = document.getElementById('export-format').value;
            
            if (format === 'webm') {
                startVideoRecording();
            } else if (format === 'gif') {
                startGifRecording();
            }
        }

        function startVideoRecording() {
            recordedChunks = [];
            const stream = renderer.domElement.captureStream(params.exportFps);
            
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 5000000
            });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                document.getElementById('recording-indicator').style.display = 'none';
                document.getElementById('download-export').disabled = false;
            };

            mediaRecorder.start();
            isRecording = true;
            
            document.getElementById('recording-indicator').style.display = 'flex';
            document.getElementById('start-recording').disabled = true;
            document.getElementById('stop-recording').disabled = false;

            // Auto-stop after duration
            setTimeout(() => {
                if (isRecording) {
                    stopRecording();
                }
            }, params.exportDuration * 1000);
        }

        function startGifRecording() {
            // For GIF, we'll capture frames and use a simple approach
            recordedChunks = [];
            isRecording = true;
            
            const canvas = renderer.domElement;
            const frameInterval = 1000 / params.exportFps;
            let frameCount = 0;
            const maxFrames = params.exportDuration * params.exportFps;
            
            document.getElementById('recording-indicator').style.display = 'flex';
            document.getElementById('start-recording').disabled = true;
            document.getElementById('stop-recording').disabled = false;

            const captureFrame = () => {
                if (!isRecording || frameCount >= maxFrames) {
                    stopGifRecording();
                    return;
                }
                
                canvas.toBlob((blob) => {
                    recordedChunks.push(blob);
                    frameCount++;
                    setTimeout(captureFrame, frameInterval);
                });
            };

            captureFrame();
        }

        function stopRecording() {
            if (!isRecording) return;
            
            isRecording = false;
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            document.getElementById('start-recording').disabled = false;
            document.getElementById('stop-recording').disabled = true;
        }

        function stopGifRecording() {
            isRecording = false;
            document.getElementById('recording-indicator').style.display = 'none';
            document.getElementById('start-recording').disabled = false;
            document.getElementById('stop-recording').disabled = true;
            document.getElementById('download-export').disabled = false;
        }

        function downloadExport() {
            const format = document.getElementById('export-format').value;
            
            if (format === 'webm') {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `screw_dislocation_${Date.now()}.webm`;
                a.click();
                URL.revokeObjectURL(url);
            } else if (format === 'gif') {
                // For GIF export, we create a simple animated data URL
                // Note: This is a simplified approach. For production, consider using a GIF encoding library
                alert('GIF export: ' + recordedChunks.length + ' frames captured. For best results, use the WebM format or integrate a dedicated GIF encoder library like gif.js.');
                
                // Download first frame as example
                if (recordedChunks.length > 0) {
                    const url = URL.createObjectURL(recordedChunks[0]);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `screw_dislocation_frame_${Date.now()}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
            
            document.getElementById('download-export').disabled = true;
        }

        // ==================== Initialize ====================
        
        init();
    </script>
</body>
</html>